<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title></title>
</head>
<body>
    <b><u>UPDATE by other table</u></b> <br />
    <u>mySql</u><br />
    UPDATE Workers ,Bonuses<br />
    SET salary = (Salary + Bonuses.Bonus)<br />
    WHERE Workers.WorkerId = Bonuses.WorkerId<br />
    <u>sqlServer</u><br />
    UPDATE Workers<br />
    SET Workers.Salary =  (Workers.Salary + Bonuses.Bonus)<br />
    FROM Bonuses INNER JOIN Workers ON Bonuses.WorkerId = Workers.WorkerId<br />
    <br />
    <b><u>Filters Attributes</u></b><br />
    <u>Four Basic Types of Filters</u><br />
    Authentication<br />
    Authorization<br />
    Action<br />
    Result<br />
    <br />
    [Authorize(Roles="trader")]<br />
    [OutputCache(Duration=60)]<br />
    [HttpGet]<br />
    [HandleError]<br />
    <br />
    <b><u>GET  vs POST</u></b><br />
    <u>GET</u><br />
    query string (name/value pairs) is sent in the URL of a GET request:/test/demo_form.php?name1=value1&name2=value2<br />
    GET requests can be cached<br />
    GET requests remain in the browser history<br />
    GET requests can be bookmarked<br />
    GET requests should never be used when dealing with sensitive data<br />
    GET requests have length restrictions<br />
    GET requests should be used only to retrieve data<br />
    Restrictions on data type Only ASCII characters allowed<br />
    <br />
    <u>POST</u><br />
    query string (name/value pairs) is sent in the HTTP message body of a POST request:<br />
    POST requests are never cached<br />
    POST requests do not remain in the browser history<br />
    POST requests cannot be bookmarked<br />
    POST requests have no restrictions on data length<br />
    Post No restrictions. Binary data is also allowed<br />
    <br /><br />
    
    <b><u>Net Framework</u></b>
     is a platform that provides tools and technologies to develop Windows, Web and Enterprise applications. <br />
    It mainly contains two components,<br />
1.   Common Language Runtime (CLR)<br />
2.    .Net Framework Class Library. <br />
    <br />
    <b><u>CLR</u></b><br />
    provides an environment to run all the .Net Programs. The code which runs under the CLR is called as Managed Code. <br />
    Programmers need not to worry on managing the memory if the programs are running under the CLR as it provides memory management and thread management.<br />
    CLR manages the execution of programs written in different supported languages.<br />
    CLR transforms source code into a form of bytecode known as Common Intermediate Language (CIL).<br />
    At run time, CLR handles the execution of the CIL code.<br />
    <br /><br />
    <b><u>JIT</u></b><br />
    When you compile your C# code in visual studio it gets turned into IL<br />
    During runtime the IL is interpreted into machine code and then it's executed.<br />
    This process is called Just In Time compilation or JIT for short.<br />
    Only the IL that is needed is transformed into machine code (and only once, it's "cached" once it's compiled into machinecode).<br />
    <br /><br />
    <b><u>OOP</u></b><br />
    Encapsulation :<br />
    Inheritance :<br />
    Abstraction & Encapsulation : used to display only necessary and essential features of an object to ouside the world.<br />
    Means displaying what is necessary and encapsulate the unnecessary things to outside the world.<br />
    Hiding can be achieved by using "private" access modifiers.<br />
    Polymorphism is of two types:<br />
    Compile time polymorphism/Overloading<br />
    Runtime polymorphism/Overriding<br />
    <br /><br />
    <b><u>Mutable And Immutable Class</u></b><br />
    mutable types are those whose data members can be changed after the instance is created <br />
    but Immutable types are those whose data members can not be changed after the instance is created.<br />
    strings cannot be altered. When you alter a string (by adding to it for example), you are actually creating a new string.<br />
    But StringBuilder is not immutable (rather, it is mutable)<br />
    <br /><br />
    <b><u>ArrayList vs List<> in C#</u></b><br />
    ArrayList can only create collection for Object type<br />
    List<T>
        is a generic class.<br />
        It supports storing values of a specific type without casting to or from object (which would have incurred boxing/unboxing overhead when T is a value type in the ArrayList case)<br />
        List<T>
            implements the generic IEnumerable<T>
                <br />
                interface and can be used easily in LINQ<br />
                <br /><br />
                <b><u>dynamic and generics</u></b><br />
                Generics allow you to know (at compile time) about the type you are working with (type safety)<br />
                <br /><br />
                <b><u>What does “where</u></b><br />
                generic constraints to limit the type of each generic argument<br />
                <b><u>What does “where T : class, new()”</u></b><br />
                constraint on the generic parameter T. It must be a class (reference type) and must have a public parameter-less default constructor.<br />
                That means T can't be an int, float, double, DateTime or any other struct (value type).<br />
                It could be a string, or any other custom reference type, as long as it has a default or parameter-less constructor<br />
                <br /><br />
                <b><u>browser cache is a temporary storage location on your computer for files downloaded by your browser to display websites</u></b><br />
                <br /><br />
        
                <b><u>Reflection </u></b><br />
                objects used for obtaining type information at runtime<br />
                <br /><br />
                <b><u>eval() JavaScript</u></b><br />
                evaluates JavaScript code represented as a string. console.log(eval('2 + 2'));<br />
                <br /><br />
                <b><u>Javascript call() & apply() vs bind()?</u></b><br />
                Call/apply call the function immediately,<br />
                bind returns a function that, when later executed, will have the correct context set for calling the original function.<br />
                This way you can maintain context in async callbacks and events<br />
                
        <pre>
                var person = {
                       name: "James Smith",
                       hello: function(thing)  {       
                                console.log(this.name + " says hello " + thing);<br />
                                }
                }
                </pre>
                person.hello("world");  // output: "James Smith says hello world"<br />
                person.hello.call({ name: "Jim Smith" }, "world"); // output: "Jim Smith says hello world"<br />
                var helloFunc = person.hello.bind({ name: "Jim Smith" });<br />
                helloFunc("world");  // output: Jim Smith says hello world"<br />
                <br /><br />
        
        <b><u>Ref</u></b><br />
        <pre>
        static public void DoSomething(ref TestRef t) { <br />
            t = new TestRef(); <br />
        }
        </pre>
        And t will be changed after the method has completed. an assignment is a modification of the reference, thus is lost:<br />
        <pre>
        public void Method1(object obj) { 
            obj = new Object(); 
        } 
        public void Method2(object obj) { 
            obj = _privateObject; 
        }
        </pre>
        The methods above does not modifies the original object.<br />
<br /><br />

Basically, a Task<T> "promises" to return you a T, but not right now 
        
        
        
        <div dir="rtl">
            <b><u>תאור חיפוש מהיר של שמות - autoComplete</u></b><br />
            הבעיה חיפוש מהיר ב 
            O של 1
            שמות או התחלה של שם לדוגמא : א, אב, אבר וכו <br />
            <br />פתרון אפשרי דיקשינרי או האש-טייבל שיחזיק את כל הצירופים כמפתחות ואת כל האפשרויות כערך הערך יכול להיות כמערך של שמות
            <br />לדוגמא המפתח א יהיה לו ערך מערך של השמות אברי, אברום, אברם, אבא , אקי , אמיקם וכו
            המפתח אב יהיה לו ערך מערך של השמות אברי, אברום, אברם, אבא <br />
            <br />
        <b><u>תאור מנוע חיפוש</u></b><br />     
יש צורך לחפש במהירות באלפי קבצים המכילים אלפי שורות טקסט.<br />
בעברית יש בערך 650000 מילים ( 22 אותיות לידע כללי)<br />
1. <br />נכניס את כל המילים לדיקשינרי הם יהיו המפתח ושמות הקבצים שמכילים את המילה יהיו הערך וגם הם יהיו בדיקשיונרי שבו הערך והמפתח הם שמות הקבצים
חיפוש על פי מילות מפתח יהיה מעכשיו ב "O" של 1   <br /><br />
רוצים למצוא כמה מילים במסמך לכן נצטרך למצוא את המסמכים המשותפים מכל המסמכים שחזרו בתוצאות.<br />
לכן נעשה לולאה על שמות הקבצים שחזרו מאחת המילים שחופשו ואז נבדוק בדיקשיונרי של שמות הקבצים משאר המילים שחופשו. ושוב יש לנו חיפוש ב "O" של 1 .<br />
ניתן לטייב את המסמכים בהוצאת מילות קישור וכו'<br />
        <br />
            <b><u>איפוס מערך גדול ביעילות</u></b><br />
        
על מנת להימנע מאיפוס בלולאה על המערך שבה הסיבוכיות היא "O" של "N" <br />
ניצור מערך נוסף שיחזיק את ה טיים סטמפ של השינוי בתא של המערך <br />
ברגע שמקבלים הוראת איפוס מחזיקים שני ערכים .<br />
1. <br />הערך המאפס
2. <br />טיים סטמפ של האיפוס
<br />וכך בקשת ערך מהמערך תחזיר את הערך המאפס אם ה טיים סטאמפ של הערך במערך הנוסף גדול מה  טיים סטמפ של האיפוס
        <br />
        </div>
        <br />
</body>
</html>
